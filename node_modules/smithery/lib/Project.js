"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Project = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const pm = require("picomatch");
const RuleSet_1 = require("./RuleSet");
const Generator_1 = require("./Generator");
const Parser_1 = require("./Parser");
const Imposer_1 = require("./Imposer");
const Node_1 = require("./utils/Node");
const enums_1 = require("./enums");
class Project {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
        this._config = null;
        this._ruleSet = new RuleSet_1.RuleSet();
        this._parserFactory = new Parser_1.ParserFactory();
        this._generatorFactory = new Generator_1.GeneratorFactory();
        this._imposer = new Imposer_1.Imposer(this._parserFactory, this._generatorFactory, this._ruleSet);
        this._workingDir = process.cwd();
        options = options || {};
        // we should have 3 options for configurations 
        // 1. the .smithery config file written in json
        // 2. a custom config file written in json
        // 3. configuration options directly given by the configuration options object
        // They are priorized bottom to top to allow overwriting
        const smithConfig = this.checkSmitheryConfig();
        const custConfig = this.checkCustomConfiguration(options.configPath);
        const directConfig = {
            content: {
                configs: options === null || options === void 0 ? void 0 : options.configs,
                buildFolder: options === null || options === void 0 ? void 0 : options.buildFolder,
                projectFiles: options === null || options === void 0 ? void 0 : options.projectFiles,
                plugins: options === null || options === void 0 ? void 0 : options.plugins,
                projectRules: options === null || options === void 0 ? void 0 : options.projectRules,
                exclude: options === null || options === void 0 ? void 0 : options.exclude
            },
            exists: (options === null || options === void 0 ? void 0 : options.configs) || (options === null || options === void 0 ? void 0 : options.buildFolder) || (options === null || options === void 0 ? void 0 : options.projectFiles) || (options === null || options === void 0 ? void 0 : options.projectFiles) || (options === null || options === void 0 ? void 0 : options.plugins) || (options === null || options === void 0 ? void 0 : options.projectRules) || (options === null || options === void 0 ? void 0 : options.exclude)
        };
        const errorTextSetup = `Failed to setup configuration for project at "${this._workingDir}".`;
        const errorTextInvalidConfiguration = `The used configuration for project "${this._workingDir}" is inclomplete.`;
        if (!smithConfig.exists && !custConfig.exists && !directConfig.exists) {
            throw new Error(errorTextSetup);
        }
        const config = {
            configs: '',
            buildFolder: '',
            projectFiles: '',
            plugins: [],
            projectRules: [],
            exclude: []
        };
        if (smithConfig.exists) {
            config.configs = (_b = (_a = smithConfig.content) === null || _a === void 0 ? void 0 : _a.configs) !== null && _b !== void 0 ? _b : '';
            config.buildFolder = (_d = (_c = smithConfig.content) === null || _c === void 0 ? void 0 : _c.buildFolder) !== null && _d !== void 0 ? _d : '';
            config.projectFiles = (_f = (_e = smithConfig.content) === null || _e === void 0 ? void 0 : _e.projectFiles) !== null && _f !== void 0 ? _f : '';
            config.plugins = (_h = (_g = smithConfig.content) === null || _g === void 0 ? void 0 : _g.plugins) !== null && _h !== void 0 ? _h : [];
            config.projectRules = (_k = (_j = smithConfig.content) === null || _j === void 0 ? void 0 : _j.projectRules) !== null && _k !== void 0 ? _k : [];
            if ((_l = smithConfig.content) === null || _l === void 0 ? void 0 : _l.exclude) {
                if (Array.isArray(smithConfig.content.exclude)) {
                    config.exclude = smithConfig.content.exclude;
                }
                else {
                    config.exclude = [smithConfig.content.exclude];
                }
            }
            else {
                config.exclude = [];
            }
        }
        if (custConfig.exists) {
            config.configs = ((_m = custConfig.content) === null || _m === void 0 ? void 0 : _m.configs) || config.configs;
            config.buildFolder = ((_o = custConfig.content) === null || _o === void 0 ? void 0 : _o.buildFolder) || config.buildFolder;
            config.projectFiles = ((_p = custConfig.content) === null || _p === void 0 ? void 0 : _p.projectFiles) || config.projectFiles;
            config.plugins = ((_q = custConfig.content) === null || _q === void 0 ? void 0 : _q.plugins) || config.plugins;
            config.projectRules = ((_r = custConfig.content) === null || _r === void 0 ? void 0 : _r.projectRules) || config.projectRules;
            if ((_s = custConfig.content) === null || _s === void 0 ? void 0 : _s.exclude) {
                if (Array.isArray(custConfig.content.exclude)) {
                    config.exclude = custConfig.content.exclude;
                }
                else {
                    config.exclude = [custConfig.content.exclude];
                }
            }
            else {
                config.exclude = [];
            }
        }
        if (directConfig.exists) {
            config.configs = ((_t = directConfig.content) === null || _t === void 0 ? void 0 : _t.configs) || config.configs;
            config.buildFolder = ((_u = directConfig.content) === null || _u === void 0 ? void 0 : _u.buildFolder) || config.buildFolder;
            config.projectFiles = ((_v = directConfig.content) === null || _v === void 0 ? void 0 : _v.projectFiles) || config.projectFiles;
            config.plugins = ((_w = directConfig.content) === null || _w === void 0 ? void 0 : _w.plugins) || config.plugins;
            config.projectRules = ((_x = directConfig.content) === null || _x === void 0 ? void 0 : _x.projectRules) || config.projectRules;
            if ((_y = directConfig.content) === null || _y === void 0 ? void 0 : _y.exclude) {
                if (Array.isArray(directConfig.content.exclude)) {
                    config.exclude = directConfig.content.exclude;
                }
                else {
                    config.exclude = [directConfig.content.exclude];
                }
            }
            else {
                config.exclude = [];
            }
        }
        if (typeof config.configs === 'undefined' || typeof config.buildFolder === 'undefined' || typeof config.projectFiles === 'undefined' || config.configs === '' || config.buildFolder === '' || config.projectFiles === '') {
            throw new Error(errorTextInvalidConfiguration);
        }
        // setup the configs
        if (typeof config.configs === 'string' && fs_1.existsSync(path_1.join(this._workingDir, config.configs))) {
            this._configs = this._getConfigFiles(path_1.join(this._workingDir, config.configs));
        }
        else if (typeof config.configs !== 'string') {
            this._configs = config.configs;
        }
        else {
            throw new Error('The build-configurations setup is not given properly');
        }
        // setting up the src and destination for the build
        this._buildTarget = config.buildFolder;
        // take the plugins from the config read or the options object
        if (config.plugins && Array.isArray(config.plugins)) {
            this._plugins = config.plugins;
        }
        else if (config.plugins) {
            this._plugins = [config.plugins];
        }
        else {
            this._plugins = [];
        }
        if (this._plugins && this._plugins.length > 0) {
            this._plugins.forEach((oPlugin) => this._loadPlugin(oPlugin));
        }
        if (config.projectRules &&
            typeof config.projectRules === 'string' &&
            fs_1.existsSync(path_1.join(this._workingDir, config.projectRules))) {
            const aProjectRules = this._loadProjectRules(path_1.join(this._workingDir, config.projectRules));
            this._ruleSet.addMultipleRules(aProjectRules);
        }
        this._configurationOptions = config;
    }
    checkCustomConfiguration(path) {
        if (path && path !== '') {
            if (fs_1.existsSync(path_1.join(this._workingDir, path))) {
                const cont = JSON.parse(fs_1.readFileSync(path_1.join(this._workingDir, path), 'utf-8'));
                return { content: cont, exists: true };
            }
            else {
                throw new Error(`The configuration "${path}" is not within the project folder!!`);
            }
        }
        else {
            return { exists: false };
        }
    }
    checkSmitheryConfig() {
        if (fs_1.existsSync(path_1.join(this._workingDir, 'smithery.json'))) {
            const cont = JSON.parse(fs_1.readFileSync(path_1.join(this._workingDir, 'smithery.json'), 'utf-8'));
            return { content: cont, exists: true };
        }
        else {
            return { exists: false };
        }
    }
    build(configName) {
        var _a, _b, _c, _d, _e;
        if (configName) {
            this.setConfig(configName);
        }
        if (this._config === null) {
            const oDefault = this._configs.filter((config) => config.name === 'default');
            if (oDefault.length === 0) {
                throw new Error('No configuration given, therefore no build possible!');
            }
            else {
                // tslint:disable-next-line: no-console
                console.warn('No configuration set, switching to default');
                this._config = oDefault[0];
            }
        }
        // tslint:disable-next-line: no-console
        console.log('Build start for config "' + this._config.name + '"');
        // tslint:disable-next-line: no-console
        console.log('building...');
        let aFeatures = this._config.features;
        if (!aFeatures.includes('Base')) {
            throw new Error('No Base feature set up! Build not possible!');
        }
        // now we know the features contains base, therefore we can use it.
        // exclude base from the features to be applied.
        let aBuildFeatures = aFeatures.filter((sFeatureName) => sFeatureName !== 'Base');
        //have to place it here, to always have a fresh copy of the filesystem
        //maybe we need a more performant solution
        this._projectAST =
            ((_a = this._parserFactory
                .getParser(enums_1.FileType.Folder)) === null || _a === void 0 ? void 0 : _a.parse(path_1.join(this._workingDir, this._configurationOptions.projectFiles), {
                exclude: this._configurationOptions.exclude
            })) || new Node_1.Node();
        const baseFST = ((_b = this._projectAST.children) === null || _b === void 0 ? void 0 : _b.filter((oChild) => oChild.name === 'Base')) || [];
        if (baseFST.length === 0) {
            throw new Error('Base feature is not at the source code, therefore we can not start');
        }
        let resultFST = baseFST[0].clone();
        resultFST.name = 'root';
        resultFST.featureName = 'BASE';
        while (aBuildFeatures.length > 0) {
            // Taking aFeatures like a queue
            const curFeature = aBuildFeatures.shift() || '';
            // tslint:disable-next-line: no-console
            console.log(`Imposing feature: ${curFeature}`);
            const featuresArray = ((_c = this._projectAST.children) === null || _c === void 0 ? void 0 : _c.filter((oChild) => oChild.name === curFeature)) || [];
            if (featuresArray.length === 0) {
                throw new Error(`[${curFeature}] feature is not at the source code, stopped building`);
            }
            const featureFST = featuresArray[0];
            featureFST.name = 'root';
            featureFST.featureName = curFeature.toUpperCase();
            resultFST = this._imposer.impose(resultFST, featureFST, ((_d = this._parserFactory.getParser(enums_1.FileType.Folder)) === null || _d === void 0 ? void 0 : _d.getVisitorKeys()) || {});
        }
        // check if build target already exists and clear it
        const buildRemains = this._clearBuildTarget(path_1.join(this._workingDir, this._buildTarget));
        // create the build target newly
        if (!buildRemains) {
            fs_1.mkdirSync(path_1.join(this._workingDir, this._buildTarget));
        }
        (_e = this._generatorFactory.getGenerator(enums_1.FileType.Folder)) === null || _e === void 0 ? void 0 : _e.generate(resultFST, {
            filePath: path_1.join(this._workingDir, this._buildTarget),
        });
        // tslint:disable-next-line: no-console
        console.log('Build done. -> Have fun.');
    }
    setConfig(configName) {
        if (this._configs === null || (Array.isArray(this._configs) && this._configs.length === 0)) {
            throw new Error('No configs given');
        }
        const oConfig = this._configs.filter((config) => config.name === configName);
        if (oConfig.length === 0) {
            throw new Error('Config for ' + configName + ' does not exist withing ' + (typeof this._configurationOptions.configs === 'string' ? this._configurationOptions.configs : 'configurations'));
        }
        this._config = oConfig[0];
    }
    getProjectRoot() {
        return this._configurationOptions.projectFiles;
    }
    _getConfigFiles(dirPath) {
        return fs_1.readdirSync(dirPath)
            .filter((fn) => fn.endsWith('.config'))
            .map((config) => {
            return {
                name: config.replace(dirPath + '/', '').replace('.config', ''),
                features: fs_1.readFileSync(path_1.join(dirPath, config), { encoding: 'utf-8' })
                    .split(/\r?\n/)
                    .filter((sFeature) => {
                    return sFeature !== '';
                }),
            };
        });
    }
    _loadPlugin(plugin) {
        // tslint:disable-next-line: no-console
        console.log('Try to load plugin: ' + plugin.name);
        let module = this._loadLocally(plugin.name);
        let globalStarter = false;
        if (!module && process.argv[1].indexOf('index.js') > -1) {
            globalStarter = true;
            module = this._loadGlobally(plugin.name);
        }
        if (module !== undefined) {
            if (module.parser.fileEnding && module.parser.parser) {
                if (plugin.config && plugin.config.parser) {
                    Object.keys(plugin.config.parser).forEach((key) => {
                        var _a, _b;
                        const setter = `set${this._capitalize(key)}`;
                        if (module !== undefined && typeof module.parser.parser[setter] !== 'undefined') {
                            if ((_a = plugin.config) === null || _a === void 0 ? void 0 : _a.parser) {
                                this._invokeFunktion(module.parser.parser, setter, (_b = plugin.config) === null || _b === void 0 ? void 0 : _b.parser[key]);
                            }
                        }
                        else {
                            // Log.warn(`\nNo suitable setter for configuration ${sKey} found. Will be ignored!!`)
                            // tslint:disable-next-line: no-console
                            console.log(`\nNo suitable setter for configuration ${key} found. Will be ignored!!`);
                        }
                    });
                }
                if (Array.isArray(module.parser.fileEnding)) {
                    module.parser.fileEnding.forEach((sEnding) => {
                        if (module !== undefined) {
                            this._parserFactory.addParser(module.parser.parser, sEnding);
                        }
                    });
                }
                else {
                    this._parserFactory.addParser(module.parser.parser, module.parser.fileEnding);
                }
            }
            if (module.generator !== undefined) {
                if (module.generator.fileEnding !== undefined && module.generator.generator !== undefined) {
                    if (plugin.config && plugin.config.generator) {
                        Object.keys(plugin.config.generator).forEach((sKey) => {
                            var _a;
                            const setter = `set${this._capitalize(sKey)}`;
                            if (typeof (module === null || module === void 0 ? void 0 : module.generator.generator[setter]) !== 'undefined') {
                                if ((_a = plugin.config) === null || _a === void 0 ? void 0 : _a.generator) {
                                    this._invokeFunktion(module.generator.generator, setter, plugin.config.generator[sKey]);
                                }
                            }
                            else {
                                // Log.warn(`\nNo suitable setter for configuration ${sKey} found. Will be ignored!!`)
                                // tslint:disable-next-line: no-console
                                console.log(`\nNo suitable setter for configuration ${sKey} found. Will be ignored!!`);
                            }
                        });
                    }
                    if (Array.isArray(module.generator.fileEnding)) {
                        module.generator.fileEnding.forEach((ending) => {
                            if (module !== undefined) {
                                this._generatorFactory.addGenerator(module.generator.generator, ending);
                            }
                        });
                    }
                    else {
                        this._generatorFactory.addGenerator(module.generator.generator, module.generator.fileEnding);
                    }
                }
            }
            if (module.rules) {
                if (!Array.isArray(module.rules)) {
                    // Log.error(`The rules provided by the plugin ${sPluginName} are not as an array, therefore they can not be loaded`);
                    // tslint:disable-next-line: no-console
                    console.error(`The rules provided by the plugin ${plugin.name} are not as an array, therefore they can not be loaded`);
                }
                else {
                    this._ruleSet.addMultipleRules(module.rules);
                }
            }
        }
        else {
            if (globalStarter) {
                // Log.error('Plugin could not found locally and globally install the missing plugin and restart the process.');
                // tslint:disable-next-line: no-console
                console.log('Plugin could not found locally and globally install the missing plugin and restart the process.');
            }
            else {
                // Log.error('Plugin could not be found, install and the missing plugin and restart the process.');
                // tslint:disable-next-line: no-console
                console.log('Plugin could not be found, install and the missing plugin and restart the process.');
            }
            process.exit(1);
        }
    }
    _loadProjectRules(rulePath) {
        if (fs_1.lstatSync(rulePath).isDirectory()) {
            const rules = fs_1.readdirSync(rulePath);
            const loadedRules = rules
                .map((sRulePath) => {
                try {
                    return require(path_1.join(rulePath, sRulePath));
                }
                catch (err) {
                    return;
                }
            })
                .filter((oRule) => {
                return oRule;
            });
            return loadedRules;
        }
        else {
            try {
                return [require(rulePath)];
            }
            catch (err) {
                return [];
            }
        }
    }
    _loadLocally(pluginPath) {
        try {
            return require(path_1.join(process.cwd(), 'node_modules', pluginPath));
        }
        catch (err) {
            return;
        }
    }
    _loadGlobally(pluginPath) {
        try {
            return require(path_1.join(process.argv[1].replace('index.js', ''), '../../../', pluginPath));
        }
        catch (err) {
            return;
        }
    }
    _capitalize(value) {
        return value.charAt(0).toUpperCase() + value.slice(1);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _invokeFunktion(object, fktName, argumentMap) {
        if (Array.isArray(argumentMap)) {
            object[fktName](...argumentMap);
        }
        else {
            object[fktName](argumentMap);
        }
    }
    _clearBuildTarget(buildPath) {
        var _a;
        const matcher = ((_a = this._configurationOptions) === null || _a === void 0 ? void 0 : _a.exclude) ? pm(this._configurationOptions.exclude) : undefined;
        //Firstly check if the buildPath is available
        if (!fs_1.existsSync(buildPath)) {
            return false;
        }
        if (
        //matcher is not defined
        typeof matcher === 'undefined' ||
            //matcher is defined, the buildpath exists and but the path is not excluded from build
            //therefore the files have to been kept, because the developer copied them
            typeof matcher !== 'undefined' && !matcher(buildPath)) {
            const removalResult = fs_1.readdirSync(buildPath).map((file) => {
                const curPath = path_1.join(buildPath, file);
                if (fs_1.lstatSync(curPath).isDirectory()) {
                    return this._clearBuildTarget(curPath);
                }
                else {
                    //if there is no matcher defined we can remove the file directly otherwise the path don't have to fit to the exclude pattern
                    if (typeof matcher === 'undefined' || matcher && !matcher(curPath)) {
                        fs_1.unlinkSync(curPath);
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            }).some((result) => result);
            //we can remove the directory if it does not contain any unremovable content
            if (!removalResult) {
                fs_1.rmdirSync(buildPath);
            }
            return removalResult;
        }
        else {
            // we can return because the matchers is present and says the build path should be ignored
            return true;
        }
    }
}
exports.Project = Project;
//# sourceMappingURL=Project.js.map