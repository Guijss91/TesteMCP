"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
require("mocha");
//import stuff to test
const Imposer_1 = require("./Imposer");
const RuleSet_1 = require("./RuleSet");
const Generator_1 = require("./Generator");
const Parser_1 = require("./Parser");
const Rule_1 = require("./Rule");
const Node_1 = require("./utils/Node");
describe('Check the Rule Class', () => {
    it('A Rule should be build up just by providing simple information', () => {
        const ruleSetup = {
            apply: (_, __, ___) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test'
        };
        const rule = new Rule_1.Rule(ruleSetup);
        chai_1.expect(rule).not.to.be.undefined;
    });
    it('A rule should provide correctly witch language it supports, either normal written, uppercase, lowercase', () => {
        const ruleSetup = {
            apply: (_, __, ___) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test'
        };
        const rule = new Rule_1.Rule(ruleSetup);
        chai_1.expect(rule.supportsLanguage('testing')).to.be.true;
        chai_1.expect(rule.supportsLanguage('Testing')).to.be.true;
        chai_1.expect(rule.supportsLanguage('TESTING')).to.be.true;
        chai_1.expect(rule.supportsLanguage('TeStInG')).to.be.true;
        chai_1.expect(rule.supportsLanguage('Whatsoever')).not.to.be.true;
    });
    it('A rule states if it fits to a node combination', () => {
        const ruleSetup = {
            apply: (_, __, ___) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test'
        };
        const rule = new Rule_1.Rule(ruleSetup);
        //setting up the nodes
        const baseNode = new Node_1.Node();
        const featureNode = new Node_1.Node();
        baseNode.path = 'test';
        featureNode.path = 'test';
        chai_1.expect(rule.isMatching(baseNode, featureNode)).to.be.true;
        //change the combination of nodes
        featureNode.path = 'test2';
        chai_1.expect(rule.isMatching(baseNode, featureNode)).to.be.false;
    });
    it('A rule states if it fits to a node combination, extended by node properties', () => {
        const ruleSetup = {
            apply: (base, feature, context) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test[wat]',
            selectorFeature: 'test[wat=foo]'
        };
        const rule = new Rule_1.Rule(ruleSetup);
        //setting up the nodes
        const baseNode = new Node_1.Node();
        const featureNode = new Node_1.Node();
        baseNode.path = 'test';
        featureNode.path = 'test';
        baseNode.setAttribute('wat', 'foo');
        featureNode.setAttribute('wat', 'foo');
        chai_1.expect(rule.isMatching(baseNode, featureNode)).to.be.true;
    });
    it('A rule states if it fits to a node combination, and is apply to apply the solution', () => {
        const ruleSetup = {
            apply: (base, feature, context) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test[wat]',
            selectorFeature: 'test[wat=foo]'
        };
        const rule = new Rule_1.Rule(ruleSetup);
        //setting up the nodes
        const baseNode = new Node_1.Node();
        const featureNode = new Node_1.Node();
        baseNode.path = 'test';
        featureNode.path = 'test';
        baseNode.setAttribute('wat', 'foo');
        featureNode.setAttribute('wat', 'foo');
        chai_1.expect(rule.isMatching(baseNode, featureNode)).to.be.true;
        chai_1.expect(rule.apply).to.be.not.undefined;
        const rs = new RuleSet_1.RuleSet();
        const pf = new Parser_1.ParserFactory();
        const gf = new Generator_1.GeneratorFactory();
        const imp = new Imposer_1.Imposer(pf, gf, rs);
        chai_1.expect(rule.apply(baseNode, featureNode, imp)).to.be.not.undefined;
    });
});
//# sourceMappingURL=Rule.spec.js.map