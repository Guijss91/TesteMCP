"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//setting up test environment
const chai_1 = require("chai");
require("mocha");
//import stuff to test
const RuleSet_1 = require("./RuleSet");
const Node_1 = require("./utils/Node");
const Rule_1 = require("./Rule");
describe('Check the RuleSet', () => {
    it('RuleSet should be fine after creation without parameters', () => {
        chai_1.expect(new RuleSet_1.RuleSet()).not.to.be.undefined;
    });
    it('RuleSet should add given rules for construction, additional to the default one', () => {
        const rs = new RuleSet_1.RuleSet([
            new Rule_1.Rule({
                apply: (_, __, ___) => {
                    return new Node_1.Node();
                },
                target: 'test',
                selector: 'test'
            }),
            new Rule_1.Rule({
                apply: (_, __, ___) => {
                    return new Node_1.Node();
                },
                target: 'test2',
                selector: 'test'
            }),
            new Rule_1.Rule({
                apply: (_, __, ___) => {
                    return new Node_1.Node();
                },
                target: 'test3',
                selector: 'test'
            })
        ]);
        chai_1.expect(new RuleSet_1.RuleSet()).not.to.be.undefined;
        chai_1.expect(rs.getRules().length).equals(4);
        chai_1.expect(rs.getRules().find(r => r.supportsLanguage('test'))).not.to.be.undefined;
        chai_1.expect(rs.getRules().find(r => r.supportsLanguage('test2'))).not.to.be.undefined;
        chai_1.expect(rs.getRules().find(r => r.supportsLanguage('test3'))).not.to.be.undefined;
    });
    it('RuleSet should contain the file impose pattern, if no other rules are provided', () => {
        const rs = new RuleSet_1.RuleSet();
        chai_1.expect(rs.getRules().length).equals(1);
    });
    describe('After coping a RuleSet, they should be not the same, but do not differ within thier rules', () => {
        it('Just using the default one', () => {
            const rs = new RuleSet_1.RuleSet();
            const rsCopy = rs.copy();
            chai_1.expect(rsCopy).not.to.be.equal(rs);
            chai_1.expect(rsCopy.getRules().length).equals(rs.getRules().length);
            chai_1.expect(rsCopy.getRules()[0]).not.to.be.equal(rs.getRules()[0]);
        });
        it('Using a custom fitted RulesSet', () => {
            const rs = new RuleSet_1.RuleSet();
            rs.addRule({ apply: (_, __, ___) => { return new Node_1.Node; }, target: 'test', selector: 'test' });
            rs.addRule({ apply: (_, __, ___) => { return new Node_1.Node; }, target: 'test2', selector: 'test2' });
            const rsCopy = rs.copy();
            chai_1.expect(rsCopy).not.to.be.equal(rs);
            chai_1.expect(rsCopy.getRules().length).equals(rs.getRules().length);
            chai_1.expect(rsCopy.getRules()[0]).not.to.be.equals(rs.getRules()[0]);
        });
    });
    it('Check if a manually assigned rule, is available', () => {
        const rs = new RuleSet_1.RuleSet();
        rs.addRule({
            apply: (_, __, ___) => {
                return new Node_1.Node();
            },
            target: 'test',
            selector: 'test'
        });
        chai_1.expect(rs.getRules().length).equals(2);
        chai_1.expect(rs.getRules().find(r => r.supportsLanguage('test'))).not.to.be.undefined;
    });
    it('Check if a many manually assigned rules, are available', () => {
        const rs = new RuleSet_1.RuleSet();
        const manRules = [{
                apply: (_, __, ___) => {
                    return new Node_1.Node();
                },
                target: 'test',
                selector: 'test'
            }, {
                apply: (_, __, ___) => {
                    return new Node_1.Node();
                },
                target: 'test2',
                selector: 'test'
            }, {
                apply: (_, __, ___) => {
                    return new Node_1.Node();
                },
                target: 'test3',
                selector: 'test'
            }];
        rs.addMultipleRules(manRules);
        chai_1.expect(rs.getRules().length).equals(4);
        chai_1.expect(rs.getRules().find(r => r.supportsLanguage('test'))).not.to.be.undefined;
        chai_1.expect(rs.getRules().find(r => r.supportsLanguage('test2'))).not.to.be.undefined;
        chai_1.expect(rs.getRules().find(r => r.supportsLanguage('test3'))).not.to.be.undefined;
    });
    it('Check if custom rules are used for processing', () => {
        const rs = new RuleSet_1.RuleSet();
        const rule = {
            apply: (_, __, ___) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test',
            selectorFeature: 'test'
        };
        //setting up the nodes
        const baseNode = new Node_1.Node();
        const featureNode = new Node_1.Node();
        baseNode.path = 'test';
        featureNode.path = 'test';
        //add the rule
        rs.addRule(rule);
        chai_1.expect(rs.getMatchingRule(baseNode, featureNode)).not.to.be.undefined;
    });
    it('Check if language limiting are used for processing', () => {
        const rs = new RuleSet_1.RuleSet();
        const rule = {
            apply: (_, __, ___) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test',
            selectorFeature: 'test'
        };
        //add the rule
        rs.addRule(rule);
        //setting up the nodes
        const baseNode = new Node_1.Node();
        const featureNode = new Node_1.Node();
        baseNode.path = 'test';
        featureNode.path = 'test';
        //setting language limit to 'test'
        rs.limitToLanguage('testing');
        chai_1.expect(rs.getMatchingRule(baseNode, featureNode)).not.to.be.undefined;
        //setting language limit to 'File', has to be undefined, because no rule for path 'test' available
        rs.limitToLanguage('File');
        chai_1.expect(rs.getMatchingRule(baseNode, featureNode)).to.be.undefined;
        //resetting language limit
        rs.limitToLanguage();
        chai_1.expect(rs.getMatchingRule(baseNode, featureNode)).not.to.be.undefined;
    });
    it('There should be a warning if more than one rule is matching for a FST combination', () => {
        const warnBackup = console.warn;
        const warnings = [];
        console.warn = (text) => {
            warnings.push(text);
        };
        const rs = new RuleSet_1.RuleSet();
        const rule = {
            apply: (_, __, ___) => {
                return new Node_1.Node();
            },
            target: 'testing',
            selector: 'test',
            selectorFeature: 'test'
        };
        //setting up the nodes
        const baseNode = new Node_1.Node();
        const featureNode = new Node_1.Node();
        baseNode.path = 'test';
        featureNode.path = 'test';
        //add the rule
        rs.addRule(rule);
        rs.addRule(rule);
        chai_1.expect(rs.getMatchingRule(baseNode, featureNode)).not.to.be.undefined;
        chai_1.expect(warnings.length).equals(1);
        chai_1.expect(warnings[0]).equals('More than one rule is matching! Taking the first one to proceed. Result can differ from expected Result.');
        console.warn = warnBackup;
    });
});
//# sourceMappingURL=RuleSet.spec.js.map