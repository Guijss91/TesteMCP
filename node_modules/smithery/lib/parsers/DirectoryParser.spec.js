"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//setting up the testenvironment
const chai_1 = require("chai");
require("mocha");
const sinon_1 = require("sinon");
//import stuff to test
const DirectoryParser_1 = require("./DirectoryParser");
const enums_1 = require("../enums");
const fs = require("fs");
describe('Check if the Directory Parser correctly parses file systems into the espree AST', () => {
    it('Check the correct visitor keys', () => {
        const dp = new DirectoryParser_1.DirectoryParser();
        chai_1.expect(dp).to.be.not.undefined;
        chai_1.expect(dp.getVisitorKeys()).to.be.eql({
            Folder: ['children'],
            File: []
        });
    });
    it('Check a single file to be parsed into the AST representation', () => {
        const lstatSyncStub = sinon_1.stub(fs, 'lstatSync');
        lstatSyncStub.returns({
            isFile: () => true,
            isDirectory: () => false,
            isBlockDevice: () => false,
            isCharacterDevice: () => false,
            isSymbolicLink: () => false,
            isFIFO: () => false,
            isSocket: () => false,
            dev: 0,
            ino: 0,
            mode: 0,
            nlink: 0,
            uid: 0,
            gid: 0,
            rdev: 0,
            size: 2000,
            blksize: 200,
            blocks: 2,
            atimeMs: 2000,
            mtimeMs: 2000,
            ctimeMs: 2000,
            birthtimeMs: 2000,
            atime: new Date(),
            mtime: new Date(),
            ctime: new Date(),
            birthtime: new Date()
        });
        const readFileSyncStub = sinon_1.stub(fs, 'readFileSync');
        readFileSyncStub.returns('This is the correct File content');
        const dp = new DirectoryParser_1.DirectoryParser();
        const ast = dp.parse('testPath');
        chai_1.expect(ast).not.to.be.undefined;
        chai_1.expect(ast.type).to.be.equal(enums_1.FileType.File);
        chai_1.expect(ast.content).to.be.equal('This is the correct File content');
        readFileSyncStub.restore();
        lstatSyncStub.restore();
    });
    it('Check one folder one subfile to AST production', () => {
        const lstatSyncStub = sinon_1.stub(fs, 'lstatSync');
        lstatSyncStub.onFirstCall()
            .returns({
            isFile: () => false,
            isDirectory: () => true,
            isBlockDevice: () => false,
            isCharacterDevice: () => false,
            isSymbolicLink: () => false,
            isFIFO: () => false,
            isSocket: () => false,
            dev: 0,
            ino: 0,
            mode: 0,
            nlink: 0,
            uid: 0,
            gid: 0,
            rdev: 0,
            size: 2000,
            blksize: 200,
            blocks: 2,
            atimeMs: 2000,
            mtimeMs: 2000,
            ctimeMs: 2000,
            birthtimeMs: 2000,
            atime: new Date(),
            mtime: new Date(),
            ctime: new Date(),
            birthtime: new Date()
        }).onSecondCall().returns({
            isFile: () => true,
            isDirectory: () => false,
            isBlockDevice: () => false,
            isCharacterDevice: () => false,
            isSymbolicLink: () => false,
            isFIFO: () => false,
            isSocket: () => false,
            dev: 0,
            ino: 0,
            mode: 0,
            nlink: 0,
            uid: 0,
            gid: 0,
            rdev: 0,
            size: 2000,
            blksize: 200,
            blocks: 2,
            atimeMs: 2000,
            mtimeMs: 2000,
            ctimeMs: 2000,
            birthtimeMs: 2000,
            atime: new Date(),
            mtime: new Date(),
            ctime: new Date(),
            birthtime: new Date()
        });
        const readFileSyncStub = sinon_1.stub(fs, 'readFileSync');
        readFileSyncStub.returns('This is the correct File content');
        const readdirSyncStub = sinon_1.stub(fs, 'readdirSync');
        readdirSyncStub.onFirstCall().returns(['testFile']);
        const dp = new DirectoryParser_1.DirectoryParser();
        const ast = dp.parse('testPath');
        chai_1.expect(ast).not.to.be.undefined;
        chai_1.expect(ast.type).to.be.equal(enums_1.FileType.Folder);
        chai_1.expect(ast.children).not.to.be.undefined;
        chai_1.expect(ast.children ? ast.children[0] : undefined).not.to.be.undefined;
        chai_1.expect(ast.children ? ast.children[0].type : 'FalseType').to.be.equal(enums_1.FileType.File);
        chai_1.expect(ast.children ? ast.children[0].content : 'FalseContent').to.be.equal('This is the correct File content');
        lstatSyncStub.restore();
        readFileSyncStub.restore();
        readdirSyncStub.restore();
    });
});
//# sourceMappingURL=DirectoryParser.spec.js.map