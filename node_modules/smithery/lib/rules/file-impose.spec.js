"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const file_impose_1 = require("./file-impose");
const Node_1 = require("../utils/Node");
const Imposer_1 = require("../Imposer");
const chai_1 = require("chai");
const sinon = require("sinon");
const Parser_1 = require("../Parser");
const Generator_1 = require("../Generator");
const api_1 = require("../api");
class MockParser {
    parse(content, options) {
        return new Node_1.Node();
    }
    getVisitorKeys() {
        return {};
    }
}
class MockGenerator {
    generate(oAST, options) {
        return 'blub';
    }
}
describe('Check if the rule for file imposing works correctly', () => {
    let parserMock;
    before(() => {
        parserMock = new MockParser();
    });
    it('Should throw an error if there is no parser for the base AST', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'FOO';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'FOO');
        chai_1.assert.throws(() => { file_impose_1.rule.apply(baseAST, featureAST, imp); }, 'Base-FeatureTree-Parser or Feature-FeatureTree-Parser not correctly defined');
    });
    it('Should throw an error if there is no parser for the feature AST', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'FOO';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'WAT');
        chai_1.assert.throws(() => { file_impose_1.rule.apply(baseAST, featureAST, imp); }, 'Base-FeatureTree-Parser or Feature-FeatureTree-Parser not correctly defined');
    });
    it('Should throw an error if there is no content for the base AST', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'WAT';
        featureAST.content = 'Blub';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'WAT');
        chai_1.assert.throws(() => { file_impose_1.rule.apply(baseAST, featureAST, imp); }, 'BaseFeatureTree or FeatureFeatureTree does not contain source code');
    });
    it('Should throw an error if there is no content for the feature AST', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'WAT';
        baseAST.content = 'Blub';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'WAT');
        chai_1.assert.throws(() => { file_impose_1.rule.apply(baseAST, featureAST, imp); }, 'BaseFeatureTree or FeatureFeatureTree does not contain source code');
    });
    it('Should throw an error if there is an empty content for the base AST', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'WAT';
        baseAST.content = '';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'WAT');
        chai_1.assert.throws(() => { file_impose_1.rule.apply(baseAST, featureAST, imp); }, 'BaseFeatureTree or FeatureFeatureTree does not contain source code');
    });
    it('Should throw an error if there is an empty content for the feature AST', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'WAT';
        baseAST.content = 'blub';
        featureAST.content = '';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'WAT');
        chai_1.assert.throws(() => { file_impose_1.rule.apply(baseAST, featureAST, imp); }, 'BaseFeatureTree or FeatureFeatureTree does not contain source code');
    });
    it('Should throw an error if no suitable Generator is available', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'WAT';
        baseAST.content = 'blub';
        featureAST.content = 'blub';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'WAT');
        sinon.stub(imp, 'impose').returns(new Node_1.Node());
        chai_1.assert.throws(() => { file_impose_1.rule.apply(baseAST, featureAST, imp); }, 'No suitable Generator available for feature context');
        sinon.restore();
    });
    it('Should run successfully', () => {
        const baseAST = new Node_1.Node();
        const featureAST = new Node_1.Node();
        //set a correct ending for the feature node to test only the base node;
        baseAST.ending = 'WAT';
        featureAST.ending = 'WAT';
        baseAST.content = 'blub';
        featureAST.content = 'blub';
        const imp = new Imposer_1.Imposer(new Parser_1.ParserFactory(), new Generator_1.GeneratorFactory(), new api_1.RuleSet());
        imp.getParserFactory().addParser(parserMock, 'WAT');
        const gen = new MockGenerator();
        imp.getGeneratorFactory().addGenerator(gen, 'WAT');
        sinon.stub(imp, 'impose').returns(new Node_1.Node());
        chai_1.expect(file_impose_1.rule.apply(baseAST, featureAST, imp).content).to.be.equal('blub');
        sinon.restore();
    });
});
//# sourceMappingURL=file-impose.spec.js.map